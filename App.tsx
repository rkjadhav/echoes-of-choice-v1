
import React, { useState, useEffect, useCallback } from 'react';
import { PlayerRole, ROLE_THEMES, DEFAULT_THEME, PLAYER_ROLES_ARRAY } from './constants';
import type { AppState, Choice, MemoryEntry, StoryNodeData } from './types';
import RoleSelectionScreen from './components/RoleSelectionScreen';
import NarrativeDisplay from './components/NarrativeDisplay';
import EpilogueDisplay from './components/EpilogueDisplay';
import CodexPanel from './components/CodexPanel';
import NotificationBanner from './components/NotificationBanner';
import LoadingSpinner from './components/LoadingSpinner';
import { STORY_DEFINITION, getStoryForRole, getNodeById } from './services/narrativeService';
import { generateInitialScene } from './services/geminiService'; // Ensured correct relative path

const App: React.FC = () => {
  const [appState, setAppState] = useState<AppState>({
    apiKeyFound: false,
    currentScreen: 'api_check',
    selectedRole: null,
    currentNodeId: null,
    codex: [],
    notifications: [],
    storyContent: "",
    currentChoices: [],
    theme: DEFAULT_THEME,
  });
  const [isCodexOpen, setIsCodexOpen] = useState(false);

  useEffect(() => {
    // Check for API key for Gemini.
    // For browser environments, process.env.API_KEY is often not directly available without a build step.
    // The @google/genai SDK is initialized with process.env.API_KEY as per guidelines.
    // This check informs the user and enables/disables AI features based on `window.GEMINI_API_KEY`
    // or if process.env.API_KEY happens to be set.
    const apiKey = (window as any).GEMINI_API_KEY || process.env.REACT_APP_GEMINI_API_KEY || process.env.GEMINI_API_KEY;
    if (apiKey || process.env.API_KEY) { // Also check process.env.API_KEY for completeness
      setAppState(prev => ({ ...prev, apiKeyFound: true, currentScreen: 'role_selection' }));
    } else {
      setAppState(prev => ({ ...prev, apiKeyFound: false, currentScreen: 'role_selection' }));
      addNotification("Gemini API key not found (checked window.GEMINI_API_KEY & process.env.API_KEY). AI features will use placeholders.");
    }
  }, []);

  const addNotification = useCallback((message: string) => {
    setAppState(prev => ({
      ...prev,
      notifications: [...prev.notifications, { id: Date.now(), message }],
    }));
  }, []);

  const removeNotification = useCallback((id: number) => {
    setAppState(prev => ({
      ...prev,
      notifications: prev.notifications.filter(n => n.id !== id),
    }));
  }, []);

  const addMemoryToCodex = useCallback((role: PlayerRole, entryText: string, type: MemoryEntry['type']) => {
    const newMemory: MemoryEntry = {
      id: `mem-${Date.now()}`,
      role,
      text: entryText,
      type,
      timestamp: Date.now(),
    };
    setAppState(prev => ({ ...prev, codex: [...prev.codex, newMemory] }));
  }, []);

  const handleRoleSelect = useCallback(async (role: PlayerRole) => {
    const roleStory = getStoryForRole(role);
    if (!roleStory) {
      addNotification(`Story for ${role} not found.`);
      return;
    }

    setAppState(prev => ({
      ...prev,
      selectedRole: role,
      theme: ROLE_THEMES[role] || DEFAULT_THEME,
      currentScreen: 'loading_gemini',
      codex: [], // Reset codex for new role
    }));

    let initialText = roleStory.story[roleStory.startNodeId]?.text || "The story begins...";
    if (initialText === "GEMINI_PLACEHOLDER_FOR_INTRO") { // Only try Gemini if placeholder is set
        if (appState.apiKeyFound) {
            try {
                const aiText = await generateInitialScene(role, roleStory.introPrompt);
                initialText = aiText;
                addNotification("Initial scene generated by Gemini AI.");
            } catch (error: any) {
                console.error("Error generating scene with Gemini:", error);
                addNotification(`Failed to generate AI scene: ${error.message || 'Unknown error'}. Using placeholder.`);
                initialText = `You are ${role}. ${roleStory.introPrompt.substring(0,150)}... The air is thick with anticipation. (AI placeholder)`;
            }
        } else {
             initialText = `You are ${role}. ${roleStory.introPrompt.substring(0,150)}... The air is thick with anticipation. (AI placeholder - API key not found)`;
        }
    }
    
    const startNode = getNodeById(role, roleStory.startNodeId);
    if (startNode) {
      setAppState(prev => ({
        ...prev,
        currentNodeId: roleStory.startNodeId,
        storyContent: initialText,
        currentChoices: startNode.choices,
        currentScreen: 'narrative',
      }));
       if (startNode.onEnterNotification) {
        addNotification(startNode.onEnterNotification);
      }
    }
  }, [appState.apiKeyFound, addNotification]);

  const handleChoice = useCallback((choice: Choice) => {
    if (!appState.selectedRole) return;

    const nextNode = getNodeById(appState.selectedRole, choice.nextNodeId);

    if (choice.codexEntry) {
      addMemoryToCodex(appState.selectedRole, choice.codexEntry.text, choice.codexEntry.type || 'personal');
    }
    if (choice.notification) {
      addNotification(choice.notification);
    }

    if (nextNode) {
      setAppState(prev => ({
        ...prev,
        currentNodeId: nextNode.id,
        storyContent: nextNode.text,
        currentChoices: nextNode.choices,
        currentScreen: nextNode.isEnding ? 'epilogue' : 'narrative',
      }));
      if (nextNode.onEnterNotification) {
        addNotification(nextNode.onEnterNotification);
      }
    } else {
      addNotification(`Error: Next node ${choice.nextNodeId} not found.`);
      setAppState(prev => ({ ...prev, currentScreen: 'role_selection'})); 
    }
  }, [appState.selectedRole, addMemoryToCodex, addNotification]);
  
  const restartGame = () => {
    setAppState(prev => ({
      ...prev,
      currentScreen: 'role_selection',
      selectedRole: null,
      currentNodeId: null,
      codex: [],
      storyContent: "",
      currentChoices: [],
      theme: DEFAULT_THEME,
    }));
    setIsCodexOpen(false);
  };

  return (
    <div className={`min-h-screen w-full flex flex-col items-center justify-center p-4 transition-colors duration-500 ${appState.theme.bg} ${appState.theme.text} ${appState.theme.font}`}>
      <div className="absolute top-0 right-0 p-4 space-x-2">
        {appState.currentScreen === 'narrative' && appState.selectedRole && (
           <button 
            onClick={() => setIsCodexOpen(!isCodexOpen)}
            className={`px-4 py-2 rounded ${appState.theme.buttonBg} ${appState.theme.buttonText} ${appState.theme.buttonHoverBg} transition-colors`}
            aria-label="Toggle Codex"
          >
            Codex ({appState.codex.length})
          </button>
        )}
        {(appState.currentScreen === 'narrative' || appState.currentScreen === 'epilogue') && (
          <button 
            onClick={restartGame}
            className={`px-4 py-2 rounded ${appState.theme.buttonBg} ${appState.theme.buttonText} ${appState.theme.buttonHoverBg} transition-colors`}
            aria-label="Restart Game"
          >
            Restart
          </button>
        )}
      </div>

      {appState.currentScreen === 'loading_gemini' && <LoadingSpinner message="Evoking the narrative spirits..." />}
      
      {appState.currentScreen === 'api_check' && (
        <div className="text-center">
          <LoadingSpinner message="Initializing..." />
          <p className="mt-4">Checking for Gemini API key...</p>
        </div>
      )}

      {appState.currentScreen === 'role_selection' && (
        <RoleSelectionScreen roles={PLAYER_ROLES_ARRAY.filter(r => !!STORY_DEFINITION[r])} onSelectRole={handleRoleSelect} />
      )}

      {appState.currentScreen === 'narrative' && appState.selectedRole && (
        <NarrativeDisplay
          storyContent={appState.storyContent}
          choices={appState.currentChoices}
          onChoiceSelect={handleChoice}
          theme={appState.theme}
        />
      )}

      {appState.currentScreen === 'epilogue' && (
        <EpilogueDisplay 
          epilogueText={appState.storyContent} 
          onRestart={restartGame}
          theme={appState.theme}
        />
      )}
      
      {isCodexOpen && appState.selectedRole && (
        <CodexPanel 
          codex={appState.codex} 
          role={appState.selectedRole}
          onClose={() => setIsCodexOpen(false)} 
          theme={appState.theme}
        />
      )}

      <div className="fixed bottom-0 right-0 p-4 space-y-2 w-full max-w-md">
        {appState.notifications.map(n => (
          <NotificationBanner
            key={n.id}
            message={n.message}
            onDismiss={() => removeNotification(n.id)}
          />
        ))}
      </div>
    </div>
  );
};

export default App;